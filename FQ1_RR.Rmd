---
title: "FQ1"
output: pdf_document
date: "2025-10-27"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#install.packages("pkgbuild")
#pkgbuild::check_build_tools(debug = TRUE)
#install.packages(c("Rcpp", "RcppEigen", "cli", "rlang", "vctrs", "pillar", "lifecycle"))
#install.packages(c("devtools","remotes"))
#remotes::install_github("bcm-uga/lfmm",
#                        dependencies = TRUE,
#                        build_vignettes = FALSE,
#                        force = TRUE)
#install.packages("RSpectra")

library(lme4) 
library(tibble)
library(dplyr)
library(tidyverse)
library(ggthemes)
library(ggrepel)
library(lfmm)
library(patchwork)
library(RSpectra)
load("pl_lt_t.lmer.RData")
source("manhattan_plot.R")
```

```{r}
ranef(pl_lt_t.lmer)$pop
pheno_2022 <- ranef(pl_lt_t.lmer)$pop %>%
  as_tibble(rownames = "pop",.name_repair = "unique")%>%
  rename(blup_intercept = `(Intercept)...1`,
         blup_light = `mean_light_ly_day2`) %>%
  mutate(model = "Y2022")

geno_22 <- read.delim("Data/merged_maf_common_UCD2022.tsv", header = TRUE)
```

```{r}
Y <- as.matrix(geno_22[,-1])
Y <- t(Y)
X <- matrix(scale(pheno_2022$blup_light), ncol = 1)
rownames(X) <- pheno_2022$pop
colnames(X) <- "blup_light"
common <- intersect(rownames(X), rownames(Y))
Y <- Y[common,]
X <- X[common, , drop = FALSE]
mod.lfmm <- lfmm_ridge(Y = Y, 
                        X = X, 
                        K = 2)
```

```{r}
 ## performs association testing using the fitted model:
 pv <- lfmm_test(Y = Y, 
                 X = X, 
                 lfmm = mod.lfmm, 
                 calibrate = "gif")
pvalues.calibrated <- pv$calibrated.pvalue[,1]
pvalues.raw = pv$pvalue
```

```{r}
#QQ plot
qqplot(rexp(length(pvalues.calibrated), rate = log(10)),
       -log10(pvalues), xlab = "Expected quantile",
       pch = 19, cex = .4)
abline(0,1)

n = length(sort(pvalues.calibrated))
df = tibble(observed = sort(-log10(pvalues.raw)),
expected = sort(-log10(ppoints(n))),
clower   = -log10(qbeta(p = (1 - 0.95) / 2, shape1 = 1:n, shape2 = n:1)),
cupper   = -log10(qbeta(p = (1 + 0.95) / 2, shape1 = 1:n, shape2 = n:1))
)

df |>
ggplot() +
geom_ribbon(aes(x = expected, ymin = clower, ymax = cupper), alpha = 0.1) +
geom_point(aes(expected, observed), shape = 1, size = 3) +
geom_abline(intercept = 0, slope = 1, alpha = 0.5) +
theme_bw() +
labs(x = expression(paste("Expected -log"[10], plain(P))),
y = expression(paste("Observed -log"[10], plain(P))))

```

```{r}
 ## Manhattan plot
 plot(-log10(pvalues), 
      pch = 19, 
      cex = .2, 
      xlab = "SNP", ylab = "-Log P",
      col = "grey")
```

Create a data frame for plotting the manhattan plot.

```{r}

plot_data = tibble(loci = geno_22[,1], p_val = pv$pvalue[,1], calibrated.pvalue = pv$calibrated.pvalue[,1]) |>
separate_wider_delim(loci, delim = ":", names = c("chr", "bp")) |>
filter(str_detect(chr, "Chr")) |>
mutate(p.bonf = p.adjust(p_val, method = "bonferroni"),
bp = as.numeric(bp))


light_manhattan_UCD = plot_manhattan(plot_data,
                        chr_col = "chr",
                        pos_col = "bp",
                        value_col = "calibrated.pvalue",
                        transform = "neglog10",
                        title = "Light association UCD 2022",
                        highlight_top_n = 20)

print(light_manhattan_UCD)

# Save plot
ggsave("light_interaction_UCD.png", light_manhattan_UCD, width = 12, height = 6, dpi = 300)
```


Plot the correlation of allele frequency and the blups

```{r}
geno_table = Y
colnames(geno_table) = geno_22[, 1]

freq_plot_data = as.data.frame(X) |>
rownames_to_column(var = "Population") |>
mutate(loci1 = as.numeric(geno_table[, "Chr6:20652277"]),
loci2 = as.numeric(geno_table[, "Chr4:5383224"]),
loci3 = as.numeric(geno_table[, "Chr5:14295930"])) |>
pivot_longer(cols = loci1:loci3, names_to = "loci", values_to = "frequency")

freq_plot_data |>
ggplot(aes(x = blup_light, y = frequency, label = Population)) +
geom_point(size = 3) +
geom_smooth(method = "lm", colour = "red") +
geom_text_repel(size = 6) +
facet_wrap(~loci, nrow = 1, scales = "free_y") +
theme_minimal()+
labs(x = "BLUP light", y = "Allele frequency")

```

## Now run it for the WL2 garden

```{r}
load("growth_light_time.lmer.RData")
pheno_2023 <- ranef(growth_light_time.lmer)$parent_pop %>%
  as_tibble(rownames = "parent_pop", .name_repair = "unique") %>%
  rename(blup_intercept = `(Intercept)...1`,
         blup_light = `weekly_avg_SlrW2`) %>%
  mutate(model = "Y2023")

geno_23 <- read.delim("Data/merged_maf_common_WL2_2023.tsv", header = TRUE)
```

```{r}
Y_2023 <- as.matrix(geno_23[,-1])
Y_2023 <- t(Y_2023)
X_2023 <- matrix(scale(pheno_2023$blup_light), ncol = 1)
rownames(X_2023) <- pheno_2023$parent_pop
colnames(X_2023) <- "blup_light"
common <- intersect(rownames(X_2023), rownames(Y_2023))
Y_2023 <- Y_2023[common,]
X_2023 <- X_2023[common, , drop = FALSE]
mod.lfmm <- lfmm_ridge(Y = Y_2023, 
                        X = X_2023, 
                        K = 2)
```

```{r}
 ## performs association testing using the fitted model:
pv_2023 <- lfmm_test(Y = Y_2023, 
                 X = X_2023, 
                 lfmm = mod.lfmm, 
                 calibrate = "gif")

pvalues_2023.calibrated <- pv$calibrated.pvalue[,1]
pvalues_2023.raw = pv$pvalue[,1]

n = length(sort(pvalues_2023.raw))
df = tibble(observed = sort(-log10(pvalues_2023.raw)),
expected = sort(-log10(ppoints(n))),
clower   = -log10(qbeta(p = (1 - 0.95) / 2, shape1 = 1:n, shape2 = n:1)),
cupper   = -log10(qbeta(p = (1 + 0.95) / 2, shape1 = 1:n, shape2 = n:1))
)

df |>
ggplot() +
geom_ribbon(aes(x = expected, ymin = clower, ymax = cupper), alpha = 0.1) +
geom_point(aes(expected, observed), shape = 1, size = 3) +
geom_abline(intercept = 0, slope = 1, alpha = 0.5) +
theme_bw() +
labs(x = expression(paste("Expected -log"[10], plain(P))),
y = expression(paste("Observed -log"[10], plain(P))))
```

```{r}
plot_data_2023 = tibble(loci = geno_23[,1], p_val = pv_2023$pvalue[,1], calibrated.pvalue = pv_2023$calibrated.pvalue[,1]) |>
separate_wider_delim(loci, delim = ":", names = c("chr", "bp")) |>
filter(str_detect(chr, "Chr")) |>
mutate(p.bonf = p.adjust(p_val, method = "bonferroni"),
bp = as.numeric(bp))


light_manhattan_WL2 = plot_manhattan(plot_data_2023,
                        chr_col = "chr",
                        pos_col = "bp",
                        value_col = "calibrated.pvalue",
                        transform = "neglog10",
                        title = "Light association WL2 2023",
                        highlight_top_n = 20)

print(light_manhattan_WL2)

# Save plot
ggsave("light_interaction_WL2_2023.png", light_manhattan_WL2, width = 12, height = 6, dpi = 300)
```

```{r}
light_interaction_manhattan = light_manhattan_UCD / light_manhattan_WL2
```

Top 20 from both sites

```{r}
top20_UCD = plot_data |>
slice_min(calibrated.pvalue, n = 20) |>
select(seqid = chr, bp, p_val, calibrated.pvalue, p.bonf)
write_tsv(top20_UCD, "top20_UCD_loc.tsv")

top20_WL2 = plot_data_2023 |>
slice_min(calibrated.pvalue, n = 20) |>
select(seqid = chr, bp, p_val, calibrated.pvalue, p.bonf)
write_tsv(top20_WL2, "top20_WL2_loc.tsv")
```

Now join that with the genes data and extract genes in a certain window.

```{r}
genes = read_tsv("Data/gene_description.tsv")
window_size = 10000
```

Now run the code to find nearby genes for UCD 2022

```{r}
genes_near_snps_UCD = top20_UCD |>
  left_join(genes, by = "seqid", relationship = "many-to-many") |>
  mutate(
    # Calculate distances
    dist_to_start = bp - start,
    dist_to_end = bp - end,
    
    # Check if SNP is within gene body
    in_gene = bp >= start & bp <= end,
    
    # Check if SNP is within window (upstream or downstream)
    in_window = (bp >= (start - window_size) & bp <= (end + window_size))
  ) |>
  filter(in_window) |>
  mutate(
    # Categorize position
    position = case_when(
      in_gene ~ "in_gene",
      bp < start ~ "upstream",
      bp > end ~ "downstream"
    ),
    distance = case_when(
      in_gene ~ 0,
      bp < start ~ start - bp,
      bp > end ~ bp - end
    )
  ) |>
  arrange(seqid, bp, distance)

write_tsv(genes_near_snps_UCD, "../UCD_2022_genes.tsv")
```

Now run the code to find nearby genes for WL2 2023

```{r}
genes_near_snps_WL2 = top20_WL2 |>
  left_join(genes, by = "seqid", relationship = "many-to-many") |>
  mutate(
    # Calculate distances
    dist_to_start = bp - start,
    dist_to_end = bp - end,
    
    # Check if SNP is within gene body
    in_gene = bp >= start & bp <= end,
    
    # Check if SNP is within window (upstream or downstream)
    in_window = (bp >= (start - window_size) & bp <= (end + window_size))
  ) |>
  filter(in_window) |>
  mutate(
    # Categorize position
    position = case_when(
      in_gene ~ "in_gene",
      bp < start ~ "upstream",
      bp > end ~ "downstream"
    ),
    distance = case_when(
      in_gene ~ 0,
      bp < start ~ start - bp,
      bp > end ~ bp - end
    )
  ) |>
  arrange(seqid, bp, distance)

write_tsv(genes_near_snps_WL2, "../WL2_2023_genes.tsv")
```